# HttpSrv

HttpSrv is a retailed version of a lightweight HTTP server and derives from [thttpd](https://github.com/eantcal/thttpd), originally implemented to serve http GET/HEAD methods.

HttpSrv has been implemented in modern C++, which means it requires a C++14 or even C++17 compiler to be successfully built.
It has been designed to run on Linux, but it can also run on MacOS or other Unix/Posix platforms other than Windows.

HttpSrv is capable to serve multiple clients supporting GET and POST methods and has been designed to respond to the following specifications:

* Standalone application containing an embedded web server which exposes the following HTTP API for storing and retrieving text files and their associated metadata:
* `POST` `some_file.txt` to `/store`: returns a JSON payload with file metadata containing name, size (in bytes), request timestamp and an auto-generated ID
* `GET` `/files`: returns a JSON payload containing an array of files metadata containing file name, size (in bytes), timestamp and ID
* `GET` `/files/{id}`: returns a JSON payload with file metadata containing name, size (in bytes), timestamp and ID for the provided ID `id`
* `GET` `/files/{id}/zip`: returns a zip archive containing the file which corresponds to the provided ID `id`
* `GET` `/mrufiles`: returns a JSON payload with an array of files metadata containing file name, size (in bytes), timestamp and ID for the top `N` most recently accessed files via the `/files/{id}` and `/files/{id}/zip` endpoints. `N` should be a configurable parameter for this application.
* `GET` `/mrufiles/zip`: returns a zip archive containing the top `N` most recently accessed files via the `/files/{id}` and `/files/{id}/zip` endpoints. `N` should be a configurable parameter for this application.

## HttpSrv architecture

HttpSrv is a console application (which can be easily daemonized via external command like daemonize, if required).
Its main thread executes the main HTTP server loop. Each client request, a separate HTTP session, is then handled in a specific thread. Once the session terminates, the thread and related resources are freed.

When a client POSTs a new file, that file is stored in a specific `repository` (which is basically a dedicated directory).
`File metadata` is always generated by reading the file attributes, while an id-to-filename thread-safe map (`FilenameMap` instance) is shared among the HTTP sessions (threads), and used to retreive the `filename` for a given `id`. The `id` is generated by a hash code function (which executes the SHA256 algorithm).
When a zip archive is required, that is generated on-the-fly in a temporary directory and sent to the client. Eventually the temporary directory and its content is cleaned up.

### Configuration and start-up

HttpSrv entry point, the application `main()` function, creates a `class Application` object which is in turn a builder for classes `FileRepository` and `HttpServer`:

* `FileRepository` provides methods for:
  * accessing the filesystem,
  * creating the repository directory,
  * managing the temporary directories required for sending the zip archives,
  * creating zip archives,
  * creating and handling the `FilenameMap` object
  * formatting the JSON metadata
* `HttpServer` implements the HTTP server main loop:
  * accepting a new TCP connection and
  * finally creating HTTP sessions (`HTTPSession`) where the API business logic is implemented.

The file repository directory (if not already existent) is created in the context `FileRepository` initialization.
The repository directory path can be configured at start-up. By default, it is a subdir of user home directory named `“.httpsrv”` for ‘unix’ platforms, `“httpsrv”` for Windows.

When the initialization is completed, the application object calls the method `run()` of `HttpServer` object. Such method is blocking for the caller, so unless the application is executed as background process or daemon, it will block the caller process (typically the shell).
The server is designed to bind on any interfaces and a specific and configurable TCP port (which is `8080`, by default).

### Main server loop

The method `HttpServer::run()` executes a loop that, for each iteration, waits for incoming connection by calling `accept()` method which will eventually result in calling `accept()` function of socket library.
When `accept()` accepts a connection, `run()` gets a new `TcpSocket` object, which represents the TCP session, and creates a new HTTP Session handled by instance of class `HttpSession`.
Each HTTP Session runs in a separate thread so multiple requests can be served concurrently.

### Concurrent operations by multiple clients

* Concurrent GET operations not altering the timestamp can be executed without any conflicts.
* Concurrent POST or GET (id or id/zip) for the **same** files might produce a JSON metadata which does not reflect -- for some concurrent clients -- the actual repository status. This is what commonly happens in a shared and unlocked unix filesystem that implements a optimistic non-locking policy. While running on locked filesystem which implements an exclusive access policy, one of the concurrent operation might fail generating an error to the client.
Get operations which require a zip file can be executed cuncurrently without conflicts: the zip file is created in a unique `temporary-directory` whose name is generated randomically, so its integrity is always preserved.
In absence of specific requirements it has been decided not to implement a strictly F/S locking mechanism, adopting indeed an optimistic policy. The rationale is to maintain the design simple, also considering the remote chance of conflicts and their negligible effects.
The file `id` is a hash code of file name (which is in turn assumed to be unique), so any conflicts would have no impact on its validity, moreover the class `FilenameMap` (which provides the methods to resolve the filename for a given id) is designed to be thread-safe (r/w locking mechanism is used for the purposes). So the design should avoid that concurrent requests resulted in server crash or asymptotic instability.

### Resiliency

The application is also designed to be recover from intentional or unintentional restart.
For such reason, HttpSrv updates the `FilenameMap` object at start-up (reading the repository files list), as the http requests are not accepted yet, getting the status of any files present in the configured repository path. This allows the server to restart from a given repository state.

Multiple instances of HttpSrv could be run concurrently on the same system, binding on separate ports. In case they share the same repository, it is not guaranteed that a file posted from a server can be visible to another server (until such server executes a request for file list or is restarted) because the `FilenameMap` object would be stored in each (isolated) process memory.

`GET` and `POST` requests are processed within a `HTTPSession` loop which consists in:

* reading receiving and parsing an http request (`HttpRequest`)
* validating and classifieng the request
* executing the business logic related to the request (GET/POST)
* creating a response header + a body (`HTTPResponse`)
* cleaning-up resourses (deleting for example the temporary directory of a zip file sent to the client) and ending the session

#### POST

When a file is uploaded, the POST business logic consists in:

* (in absence of errors) writing the file in the repository;
* updating id-filename map (`FilenameMap`);
* generates a JSON file metadata from stored file attribute;
* reply to the client either sending back a JSON metadata or HTTP/HTML error response depending on success or failure of one of previous steps.

#### GET

When a get request is processed the business logic performs the following action:

* `/files`: formats a JSON formatted body containing a list of metadata corrisponding to file attributes read from repository
* `/mrufiles`: likewise in `/file`, but the metadata list is generated by a timeordered list and limited to max number of mrufiles configured (3, by default)
* `/files/<id>`:
  * resolves the id via `FilenameMap` object,
  * updates the file timestamp,
  * reads the file attributes,
  * writes in the HTTP response body the JSON metadata reppresenting the file attributes
* `/files/<id>/zip`:
  * resolves the id via `FilenameMap` object,
  * updates the file timestamp,
  * reads the file attributes,
  * creates a zip archive containing the file in a unique temporary directory
  * writes the zip binary in the HTTP response body
  * cleans up the temporary directory
* `/mrufiles/zip`:
  * creates a list of mru files
  * adds each file in a new zip archive stored in unique temporary directory
  * writes the zip binary in the HTTP response body
  * cleans up the temporary directory

### HTTP Errors

HttpSrv notifies errors by using a standard HTTP error code and a related error description, formatted in HTML body.
Empty repository or zero file size is not considered an error. In the first scenario just an empty JSON list `[]` will be sent back by server on both `GET` `/files` and `GET` `/mrufiles` valid requests.
If the URI does not respect the given syntax, an `HTTP 400 Bad Request` error will be sent to the client.
If the URI does is valid but the id not found, an `HTTP 404 Not Found` error will be sent to the client.
Building a `release` version of HttpSrv binary strips out assert() calls, so in case of bugs or hardware failures or resources (e.g. memory) exhausted that might generate an `HTTP 500 Internal Server Error`.

### HTTP Server Classes

* Class `HttpServer` accepts client request and generates HttpSession in separate worker thread
* Class `HttpSession` handles the single GET/POST request and executes the related business logic
* Class `HttpSocket` provides metadata extractor for HTTP message
* Class `HttpRequest` encapsulates an HTTP request providing a parser for supported request message.
* Class `HttpResponse` encapsulates an HTTP response providing a formatter for supported response message
* Class `TransportSocket` and `TcpSocket` classes expose basic socket functions including `send/recv` APIs
* Class `TcpListener` provides a wrapper of some passive TCP functions such `listen` and `accept`.

### Repository Management Classes

* Class `FileRepository` provides the support for handlig the files, reading attributes, building MRU list, formatting the JSON metadata
* Class `FilenameMap` provides id to file name resolver
* Class `ZipArchive` provides a wrapper for zip functions

### Additional Helper functions

* Functions in namepace `FileUtils` provide some f/s helpers
* Functions in namepace `StrUtils` provide some string manipulation helpers
* Functions in namepace `SysUtils` provide some helpers not belonging to previous two categories

### Timestamp and precision

File timestamp is a GMT representation of last access attribute of a file (as documented in `stat` syscall). Some filesystem could not support microsecond field, so the timestamp can result rounded to the second.

### 3pp

HttpSrv relies on C++ standard library (which is part of language) and other few 3pp part libraries such as:

* [PicoSHA2](https://github.com/okdshin/PicoSHA2), single header file SHA256 hash generator)
* [zip](https://github.com/kuba--/zip), a portable simple zip library written in C)
* [Boost Filesystem Library Version 3](https://www.boost.org/doc/libs/1_67_0/libs/filesystem/doc/index.htm)

Source code of such libraries (except Boost) has been copied in HttpSrv source tree in 3pp subdir. Related source code has been directly listed as part of src/include reference in the CMakeLists.txt and VS project file.

Wrapper function/class for such libraries have been provided:

* Class `ZipArchive` is a wrapper on employed `zip` functions
* `hashCode()` function part of `FileUtils.h` is a wrapper for `picosha2::hash256_hex_string` function
Boost Filesystem can be replaced by C++ standard version if fully supported by C++ compiler (defining the preprocessor symbol `USE_STD_FS` at compile time).

## Known Limitations

* HTTP protocol has been supported only for providing the specific API exposed.
* Timestamp precision of some filesystem implementation might not support the microseconds field as result two files will have different timestamps if differ at least for 1 second. 

## Test
A functional test implemented as [BASH script](test/functional_test.sh) has been provided to verify the main use scenarios. It relies on a number of welknown 3pp commands/tools including `grep`, `awk`, `sed`, `unzip`, `curl`, `jsonlint`, `sha256sum`. 
To execute the functional tests the httpsrv binary must be running (by default bound on localhost:8080).
The script accept as an optional parameter `hostname:port` (same syntax of curl).
The test shows a detailed log during the execution.
If the test completes sucessfully it prints out a detailed [summary](misc/example_of_positive_test_result.txt)
In case of error the test stops showing a related message leaving the log visible in the stdout/stderr.

### What is missing?

Even if the functional tests sollicit the application in the most common scenarios, a complete test framework should include:
* Unit test for each class/function exposed 
* Automatic stress tests (valgrind could be used to check for memory leaks)
* Concurrent automatic tests
* httpsrv log analysis to check for internal errors
An automation server like [Jenkins](https://jenkins.io/) could be used.
Additional tools for checking code coverege and static analysis could be used as well.

## C++ Compiler Prerequisites

To compile HttpSrv you will need a compiler supporting modern C++ 
Tested on latest versions GCC, Microsoft Visual C++, (Apple) Clang.

### Windows Installation Prerequisites
To install successfully the following software component is required on the installation computer:
- Visual C++ Redistributable Packages are required.
- Boost binaries for Windows

### Tested Platforms

Tested on the following platforms:
CMake support and Visual Studio 2019 project files are provided.
The server has been built and tested on Linux, MacOS and Windows, more precisely it has been tested on:

* Darwin (18.7.0 Darwin Kernel Version 18.7.0) on MacBook Pro, built using Apple clang version 11.0.0 (clang-1100.0.20.17), Target: x86_64-apple-darwin18.7.0, Thread model: posix, cmake version 3.12.2
* Linux 5.0.0-38-generic #41-Ubuntu SMP Tue Dec 3 00:27:35 UTC 2019 x86_64 GNU/Linux, built using g++ (Ubuntu 8.3.0-6ubuntu1) 8.3.0, CMake version 3.13.4
* Windows 10 built using Visual Studio 2019

### Build
### Logs
### TODO...

### HttpSrv command line options:

```
Usage:
	./httpsrv
		-p | --port <port>
			Bind server to a TCP port number (default is 8080) 
		-n | --mrufiles <N>
			MRU Files N (default is 3) 
		-w | --storedir <working_dir_path>
			Set a local working directory (default is ~/.httpsrv) 
		-vv | --verbose
			Enable logging on stderr
		-v | --version
			Show software version
		-h | --help
			Show this help 

```

